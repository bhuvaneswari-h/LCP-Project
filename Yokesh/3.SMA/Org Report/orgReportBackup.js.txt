let errorMessage = "";
let organizationId = postData.organizationId;
let assessmentId = postData.assessmentId;


//get organisation and assessment level users
let organisationAssessmentInfo = await selectTableData({
    compName: "SMAClientUserMap",
    recordCount: 0,
    selectSpecs: [
        { fieldName: "User_Id" }
    ],
    whereSpecs: [
        { fieldName: "Client_Id", fieldOperator: "=", fieldValue: organizationId },
        { fieldName: "Survey_Id", fieldOperator: "=", fieldValue: assessmentId }
    ],
    type: "view"
});

organisationAssessmentInfo = [
  {
    "User_Id": 3932
  },
  {
    "User_Id": 3933
  },
  {
    "User_Id": 3934
  },
  {
    "User_Id": 3953
  },
  {
    "User_Id": 3930
  }
]

let surveyCategory = await selectTableData({
    compName: "SMASurveyCategory",
    recordCount: 0,
    selectSpecs: [
        { fieldName: "surveyId" }, { fieldName: "categoryId" }
    ],
    whereSpecs: [
    ]
});

let surveyProgress = await selectTableData({
    compName: "SMASurveyProgress",
    recordCount: 0,
    selectSpecs: [
        { fieldName: "userId" }, { fieldName: "surveyId" }, { fieldName: "status" }, { fieldName: "categoryId" }
    ],
    whereSpecs: [

    ]
});

// Function to find category IDs for a given survey
function getCategoryIdsForSurvey(surveyId) {
    return surveyCategory
        .filter(category => category.surveyId === surveyId)
        .map(category => category.categoryId);
}


// Function to check if a user has completed all categories for a given survey
function hasUserCompletedSurvey(userId, surveyId) {
    const requiredCategories = getCategoryIdsForSurvey(surveyId);
    const userProgress = surveyProgress.filter(progress => progress.userId === userId && progress.surveyId === surveyId && progress.status === "Completed");
    const completedCategories = userProgress.map(progress => progress.categoryId);
    return requiredCategories.every(categoryId => completedCategories.includes(categoryId));

}

// resolve({"yoki hasUserCompletedSurvey": hasUserCompletedSurvey(3930 ,assessmentId)})




// Check for each user in organisationAssessmentInfo if they have completed the survey with assessmentId

// const result = organisationAssessmentInfo.map(info => ({
//     UserId: info.User_Id,
//     HasCompletedSurvey: hasUserCompletedSurvey(info.User_Id, assessmentId)
// }));

const result = organisationAssessmentInfo.map(info => {
    const bool = hasUserCompletedSurvey(info.User_Id, assessmentId);
    if (bool) {
        return info.User_Id;
    } else {
        return null;
    }
}).filter(id => id !== null);




// if (organisationAssessmentInfo) {
// assignedOrganisationAssisment = organisationAssessmentInfo.id;    

//Get all the invited users in organisation
/*    let organisationAssessmentUserList = await selectTableData({
        compName: "AssessmentInvites",
        recordCount: 0,
        selectSpecs: [        
            { fieldName: "userId" }
        ],
        whereSpecs: [
            { fieldName: "OrgAssessmentId", fieldOperator: "=", fieldValue: organizationId},                
        ]
    });

    let userIds = organisationAssessmentUserList.map(user => user.userId);
*/
let organisationAssessmentCompletedUsersList = await selectTableData({
    compName: "SMASurveyProgress",
    recordCount: 0,
    selectSpecs: [
        { fieldName: "id" },
        { fieldName: "surveyId" },
        { fieldName: "userId" },
        { fieldName: "clientId" },
        { fieldName: "createdBy" }
    ],
    whereSpecs: [
        { fieldName: "status", fieldOperator: "=", fieldValue: "Completed" },
        // { fieldName: "surveyId", fieldOperator: "=", fieldValue: assessmentId},
        // { fieldName: "clientId", fieldOperator: "=", fieldValue: organizationId},
    ]
});




function getLatestUniqueEntries(data) {
    const latestEntriesMap = new Map();
    data.forEach(entry => {
        const createdBy = entry.createdBy;
        if (!latestEntriesMap.has(createdBy) || entry.id > latestEntriesMap.get(createdBy).id) {
            latestEntriesMap.set(createdBy, entry);
        }
    });
    return Array.from(latestEntriesMap.values());
}

let uniqueCompletedUsersList = getLatestUniqueEntries(organisationAssessmentCompletedUsersList);

// resolve({"yoki uniqueCompletedUsersList": uniqueCompletedUsersList})


// let completedAssessmentId = uniqueCompletedUsersList.map(assessment => assessment.id);
let completedAssessmentUsers = uniqueCompletedUsersList.map(assessment => assessment.createdBy);

// resolve({"yoki completedAssessmentUsers": completedAssessmentUsers})


// resolve({"yoki completedAssessmentId": completedAssessmentId})
// resolve({"yoki completedAssessmentUsers": completedAssessmentUsers})




//Get name of the users
let assessmentUsers
    = await selectTableData({
        compName: "users",
        recordCount: 0,
        selectSpecs: [
            { fieldName: "id" }, { fieldName: "FullName" }
        ],
        whereSpecs: [
            { fieldName: "id", fieldOperator: "IN", fieldValue: completedAssessmentUsers },
        ]
    });

// resolve(assessmentUsers)    

//Get all invited users & assessmentsId who completed the assessment with questions & answers
let users = assessmentUsers.map(user => user.id);

// resolve(users)    


let completedAssessmentReport = await selectTableData({
    compName: "SMACompletedSurveyReportView",
    recordCount: 0,
    selectSpecs: [
        { fieldName: "title" },
        { fieldName: "userId" },
        { fieldName: "FullName" },
        { fieldName: "categoryName" },
        { fieldName: "subCategoryName" },
        { fieldName: "questionText" },
        { fieldName: "answerText" },
        { fieldName: "score" },
        { fieldName: "surveyId" },
        { fieldName: "id" },
        { fieldName: "answersCount" },
        { fieldName: "created" },
        { fieldName: "name" },
    ],
    whereSpecs: [
        { fieldName: "id", fieldOperator: "=", fieldValue: assessmentId },
        { fieldName: "userId", fieldOperator: "IN", fieldValue: result },
        // { fieldName: "surveyId", fieldOperator: "IN", fieldValue: completedAssessmentId }
    ],
    type: "view",
});

// resolve({"organisationAssessmentInfo": organisationAssessmentInfo, "surveyCategory": surveyCategory, "surveyProgress": surveyProgress,
// "organisationAssessmentCompletedUsersList": organisationAssessmentCompletedUsersList, "assessmentUsers": assessmentUsers, "completedAssessmentReport": completedAssessmentReport})



// Process the completed assessment report to structure the response
let assessmentReport = {};

completedAssessmentReport.forEach(question => {
    let completedAssessmentId = question.surveyId;
    let createdDate = new Date(question.created); // Convert created to a Date object for easier comparison

    // Initialize the assessment entry if it doesn't exist
    if (!assessmentReport[completedAssessmentId]) {
        assessmentReport[completedAssessmentId] = {
            assessmentId: question.surveyId,
            userId: question.userId,
            userName: question.FullName,  // Store the FullName as userName
            assessmentName: question.title,
            created: createdDate,
            organisationId: organizationId,
            organisationName: question.name,
            subjects: {}
        };
    }

    // Check if the current entry has a newer created date
    if (assessmentReport[completedAssessmentId].created < createdDate) {
        assessmentReport[completedAssessmentId].created = createdDate;
    }

    // Add or update subjects and questions
    let subject = question.categoryName;
    // Initialize the subject if it doesn't exist
    if (!assessmentReport[completedAssessmentId].subjects[subject]) {
        assessmentReport[completedAssessmentId].subjects[subject] = {
            subjectName: subject,
            questions: {}
        };
    }

    // Create a unique identifier for the question
    let questionKey = `${question.subCategoryName}-${question.questionText}`;

    // Add or update the question details
    assessmentReport[completedAssessmentId].subjects[subject].questions[questionKey] = {
        topicName: question.subCategoryName,
        questionText: question.questionText,
        answerText: question.answerText,
        score: question.score,
        maxScore: question.answersCount
    };
});


// resolve({"yoki": assessmentReport})


let reportData = Object.values(assessmentReport).map(entry => {
    if (entry.userId !== 0) {
        return {
            assessmentId: entry.assessmentId,
            userId: entry.userId,
            userName: entry.userName,
            assessmentName: entry.assessmentName,
            created: entry.created,
            organisationId: entry.organisationId,
            organisationName: entry.organisationName,
            subjects: Object.values(entry.subjects).map(subject => ({
                subjectName: subject.subjectName,
                questions: Object.values(subject.questions)
            }))
        };
    }
    // Return null or an empty object for entries with userId 0 (excluded from response)
    return null;
}).filter(Boolean); // Filter out any null values (entries with userId 0)

resolve({ reportData: reportData, message: "", statusCode: 200 });

/*} else {
    resolve({ message: "Assessment Not Found For The Organisation!", statusCode: 404 });
}
*/